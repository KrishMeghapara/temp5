================================================================================
ASP.NET CORE WEB API - COMPLETE IMPLEMENTATION DOCUMENTATION
================================================================================

================================================================================
1. PROJECT OVERVIEW
================================================================================

The API is built using .NET 8 (or latest) with Swagger enabled for API testing 
and documentation. The architecture ensures scalability, maintainability, and 
security.

Key Features: Production-ready ASP.NET Core Web API with modern best practices, 
comprehensive security, and developer-friendly documentation.

FEATURES:
â€¢ Modern Stack - .NET 8 with latest features and performance improvements
â€¢ Swagger Integration - Interactive API documentation and testing interface
â€¢ Enterprise Security - JWT authentication with role-based authorization
â€¢ Scalable Architecture - Clean code structure designed for growth

================================================================================
2. GETTING STARTED
================================================================================

Follow these steps to set up and run the ASP.NET Core Web API on your local 
development environment.

PREREQUISITES:
â€¢ .NET 8 SDK or later
â€¢ SQL Server (LocalDB, Express, or Full version)
â€¢ Visual Studio 2022 or VS Code with C# extension
â€¢ Postman or similar API testing tool (optional)

INSTALLATION STEPS:

Step 1: Create New Project
---------------------------
dotnet new webapi -n MyWebApi
cd MyWebApi

Step 2: Install Required Packages
----------------------------------
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
dotnet add package Swashbuckle.AspNetCore

Step 3: Configure Connection String
------------------------------------
Update your appsettings.json file:

{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=MyApiDb;Trusted_Connection=true;"
  },
  "Jwt": {
    "Key": "YourSuperSecretKeyHere123456789",
    "Issuer": "https://localhost:7001",
    "Audience": "https://localhost:7001"
  }
}

Step 4: Run Database Migrations
--------------------------------
dotnet ef migrations add InitialCreate
dotnet ef database update

Step 5: Run the Application
----------------------------
dotnet run

âœ“ Your API should now be running at https://localhost:7001 and Swagger UI at 
https://localhost:7001/swagger

================================================================================
3. STANDARD API RESPONSE MODEL
================================================================================

All endpoints return a consistent response structure to ensure predictable 
client-side handling. This standardization simplifies error handling and data 
processing across your application.

CODE:
-----
public class ApiResponse<T>
{
    public bool Error { get; set; }
    public string Message { get; set; }
    public T Data { get; set; }
}

RESPONSE PROPERTIES:
â€¢ Error: Boolean flag indicating operation success or failure
â€¢ Message: Human-readable description of the operation result
â€¢ Data: Generic type containing the actual response payload

This pattern ensures consistent error handling and makes it easier to build 
robust client applications.

================================================================================
4. DATABASE CONFIGURATION
================================================================================

Entity Framework Core is used with SQL Server for data persistence. The 
DbContext manages entity relationships and database operations with a clean, 
type-safe API.

CODE:
-----
public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) 
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; }
    public DbSet<Product> Products { get; set; }
}

CONFIGURATION FEATURES:
â€¢ Entity Framework Core for ORM capabilities
â€¢ SQL Server as the primary database provider
â€¢ DbSet collections for entity management
â€¢ Migration support for schema versioning
â€¢ LINQ query support for type-safe data access

================================================================================
5. JWT AUTHENTICATION
================================================================================

JWT (JSON Web Token) is implemented to secure the API endpoints. Token 
validation ensures issuer, audience, lifetime, and signing key integrity for 
robust security.

CODE:
-----
builder.Services.AddAuthentication("Bearer")
    .AddJwtBearer("Bearer", options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true
        };
    });

builder.Services.AddAuthorization();

SECURITY VALIDATIONS:
â€¢ Issuer Validation: Ensures tokens come from trusted sources
â€¢ Audience Validation: Verifies tokens are intended for this API
â€¢ Lifetime Validation: Checks token expiration timestamps
â€¢ Signing Key Validation: Confirms token signature integrity

JWT provides stateless authentication, enabling horizontal scaling without 
session storage.

================================================================================
6. SWAGGER CONFIGURATION
================================================================================

Swagger provides interactive API documentation and testing capabilities. This 
configuration integrates JWT Bearer authentication into Swagger UI, allowing 
you to test protected endpoints.

COMPLETE SWAGGER SETUP WITH JWT:
---------------------------------
Add the following configuration to your Program.cs file:

builder.Services.AddSwaggerGen(options =>
{
    options.AddSecurityDefinition("Bearer", new Microsoft.OpenApi.Models.OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = Microsoft.OpenApi.Models.SecuritySchemeType.Http,
        Scheme = "bearer",
        BearerFormat = "JWT",
        In = Microsoft.OpenApi.Models.ParameterLocation.Header,
        Description = "JWT Authorization header using the Bearer scheme."
    });

    options.AddSecurityRequirement(new Microsoft.OpenApi.Models.OpenApiSecurityRequirement
    {
        {
            new Microsoft.OpenApi.Models.OpenApiSecurityScheme
            {
                Reference = new Microsoft.OpenApi.Models.OpenApiReference
                {
                    Type = Microsoft.OpenApi.Models.ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },
            Array.Empty<string>()
        }
    });
});

CONFIGURATION BREAKDOWN:

Security Definition:
â€¢ Name: "Authorization" - The header name where the token will be sent
â€¢ Type: Http - Specifies HTTP authentication scheme
â€¢ Scheme: "bearer" - Uses Bearer token authentication
â€¢ BearerFormat: "JWT" - Indicates the token format
â€¢ In: Header - Token is sent in the request header

Security Requirement:
The AddSecurityRequirement method applies the Bearer authentication globally 
to all endpoints in Swagger UI. This adds the "Authorize" button to the 
Swagger interface.

ENABLE SWAGGER MIDDLEWARE:
--------------------------
Add these lines to enable Swagger in your application pipeline:

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "My API V1");
        c.RoutePrefix = "swagger";
    });
}

USING SWAGGER WITH JWT:

Step 1: Obtain JWT Token
-------------------------
First, call your login endpoint to get a JWT token:

POST /api/auth/login
{
  "username": "admin@example.com",
  "password": "Admin@123"
}

Response:
{
  "error": false,
  "message": "Login successful",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}

Step 2: Authorize in Swagger
-----------------------------
Click the "Authorize" button at the top of Swagger UI, paste your token 
(without "Bearer" prefix), and click "Authorize". All subsequent requests 
will include the JWT token automatically.

Step 3: Test Protected Endpoints
---------------------------------
Now you can test any protected endpoint. Swagger will automatically include 
the Authorization header with your JWT token in all requests.

Important: Only enable Swagger in development environments. For production, 
remove or secure the Swagger endpoint to prevent exposing your API structure.

================================================================================
7. ROLE-BASED AUTHORIZATION
================================================================================

Role-based access control restricts endpoint access based on user roles such 
as Admin or User. This ensures proper separation of concerns and security 
boundaries.

CODE:
-----
[Authorize(Roles = "Admin")]
[HttpPost]
public IActionResult CreateProduct(Product product)
{
    // Only users with Admin role can access this endpoint
    _context.Products.Add(product);
    _context.SaveChanges();
    
    return Ok(new ApiResponse<Product>
    {
        Error = false,
        Message = "Product created successfully",
        Data = product
    });
}

AUTHORIZATION FEATURES:
â€¢ Attribute-based role enforcement
â€¢ Multiple role support per endpoint
â€¢ Automatic 401/403 responses for unauthorized access
â€¢ Claims-based identity integration
â€¢ Policy-based authorization support

================================================================================
8. CRUD OPERATIONS
================================================================================

The API provides full Create, Read, Update, and Delete functionality using 
standardized responses. All operations follow RESTful conventions and return 
consistent ApiResponse wrappers.

GET ALL PRODUCTS:
-----------------
[HttpGet]
public IActionResult GetAll()
{
    var products = _context.Products.ToList();
    
    return Ok(new ApiResponse<List<Product>>
    {
        Error = false,
        Message = "Operation Successful",
        Data = products
    });
}

GET PRODUCT BY ID:
------------------
[HttpGet("{id}")]
public IActionResult GetById(int id)
{
    var product = _context.Products.Find(id);
    
    if (product == null)
    {
        return NotFound(new ApiResponse<Product>
        {
            Error = true,
            Message = "Product not found",
            Data = null
        });
    }
    
    return Ok(new ApiResponse<Product>
    {
        Error = false,
        Message = "Product retrieved successfully",
        Data = product
    });
}

SUPPORTED OPERATIONS:
â€¢ GET: Retrieve single or multiple resources
â€¢ POST: Create new resources
â€¢ PUT: Update existing resources
â€¢ DELETE: Remove resources

================================================================================
9. API ENDPOINTS
================================================================================

Complete reference of all available API endpoints with request/response examples.

AUTHENTICATION ENDPOINTS:
-------------------------

POST /api/auth/register
Register a new user account

Request Body:
{
  "username": "user@example.com",
  "password": "User@123",
  "role": "User"
}

Response:
{
  "error": false,
  "message": "User registered successfully",
  "data": {
    "id": 1,
    "username": "user@example.com",
    "role": "User"
  }
}

---

POST /api/auth/login
Authenticate and receive JWT token

Request Body:
{
  "username": "user@example.com",
  "password": "User@123"
}

Response:
{
  "error": false,
  "message": "Login successful",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiration": "2024-12-31T23:59:59Z"
  }
}

PRODUCT ENDPOINTS:
------------------

GET /api/products
Get all products

Response:
{
  "error": false,
  "message": "Operation successful",
  "data": [
    {
      "id": 1,
      "name": "Product 1",
      "price": 99.99,
      "description": "Product description"
    }
  ]
}

---

GET /api/products/{id}
Get product by ID

Response:
{
  "error": false,
  "message": "Product retrieved successfully",
  "data": {
    "id": 1,
    "name": "Product 1",
    "price": 99.99,
    "description": "Product description"
  }
}

---

POST /api/products ðŸ”’ Admin Only
Create a new product

Request Body:
{
  "name": "New Product",
  "price": 149.99,
  "description": "Product description"
}

Response:
{
  "error": false,
  "message": "Product created successfully",
  "data": {
    "id": 2,
    "name": "New Product",
    "price": 149.99,
    "description": "Product description"
  }
}

---

PUT /api/products/{id} ðŸ”’ Admin Only
Update an existing product

Request Body:
{
  "name": "Updated Product",
  "price": 199.99,
  "description": "Updated description"
}

Response:
{
  "error": false,
  "message": "Product updated successfully",
  "data": {
    "id": 1,
    "name": "Updated Product",
    "price": 199.99,
    "description": "Updated description"
  }
}

---

DELETE /api/products/{id} ðŸ”’ Admin Only
Delete a product

Response:
{
  "error": false,
  "message": "Product deleted successfully",
  "data": null
}

Note: Endpoints marked with ðŸ”’ require authentication and specific roles. 
Include the JWT token in the Authorization header: Bearer {token}

================================================================================
10. ERROR HANDLING
================================================================================

The API implements comprehensive error handling to provide clear, actionable 
error messages to clients while maintaining security best practices.

STANDARD ERROR RESPONSE:
------------------------
All errors follow the same ApiResponse structure:

{
  "error": true,
  "message": "Descriptive error message",
  "data": null
}

HTTP STATUS CODES:
------------------
Status Code | Meaning                  | When Used
------------|--------------------------|------------------------------------------
200 OK      | Success                  | Request completed successfully
201 Created | Resource Created         | New resource created successfully
400 Bad     | Invalid Input            | Validation errors or malformed request
401 Unauth  | Not Authenticated        | Missing or invalid JWT token
403 Forbid  | Not Authorized           | User lacks required role/permissions
404 Not     | Resource Not Found       | Requested resource doesn't exist
500 Server  | Server Error             | Unexpected server-side error

COMMON ERROR SCENARIOS:

Validation Error (400):
{
  "error": true,
  "message": "Validation failed",
  "data": {
    "errors": {
      "Name": ["The Name field is required."],
      "Price": ["Price must be greater than 0."]
    }
  }
}

Authentication Error (401):
{
  "error": true,
  "message": "Invalid credentials",
  "data": null
}

Authorization Error (403):
{
  "error": true,
  "message": "You do not have permission to perform this action",
  "data": null
}

Not Found Error (404):
{
  "error": true,
  "message": "Product not found",
  "data": null
}

GLOBAL EXCEPTION HANDLER:
-------------------------
Implement a global exception handler in Program.cs:

app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        context.Response.StatusCode = 500;
        context.Response.ContentType = "application/json";

        var error = context.Features.Get<IExceptionHandlerFeature>();
        if (error != null)
        {
            var response = new ApiResponse<object>
            {
                Error = true,
                Message = "An unexpected error occurred",
                Data = null
            };

            await context.Response.WriteAsJsonAsync(response);
        }
    });
});

Security Note: Never expose sensitive error details (like stack traces or 
database connection strings) in production. Log detailed errors server-side only.

================================================================================
11. ARCHITECTURE SUMMARY
================================================================================

This implementation provides a complete, production-ready foundation for 
building secure and scalable web APIs with ASP.NET Core.

KEY COMPONENTS:
â€¢ Entity Framework Core - SQL Server integration with type-safe queries
â€¢ JWT Authentication - Secure API access with token validation
â€¢ Role-Based Authorization - Endpoint protection with user roles
â€¢ Standardized Responses - ApiResponse wrapper for consistency
â€¢ Full CRUD - Complete data manipulation operations
â€¢ Swagger Support - Interactive API testing and documentation

Ready for Production: This architecture follows industry best practices and 
is designed to scale with your application needs.

================================================================================
END OF DOCUMENTATION
================================================================================
